/*************************************************************************
 *
 *  $RCSfile: XBreakIterator.idl,v $
 *
 *  $Revision: 1.1 $
 *
 *  last change: $Author: bustamam $ $Date: 2000-11-19 00:34:22 $
 *
 *  The Contents of this file are made available subject to the terms of
 *  either of the following licenses
 *
 *         - GNU Lesser General Public License Version 2.1
 *         - Sun Industry Standards Source License Version 1.1
 *
 *  Sun Microsystems Inc., October, 2000
 *
 *  GNU Lesser General Public License Version 2.1
 *  =============================================
 *  Copyright 2000 by Sun Microsystems, Inc.
 *  901 San Antonio Road, Palo Alto, CA 94303, USA
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License version 2.1, as published by the Free Software Foundation.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *  MA  02111-1307  USA
 *
 *
 *  Sun Industry Standards Source License Version 1.1
 *  =================================================
 *  The contents of this file are subject to the Sun Industry Standards
 *  Source License Version 1.1 (the "License"); You may not use this file
 *  except in compliance with the License. You may obtain a copy of the
 *  License at http://www.openoffice.org/license.html.
 *
 *  Software provided under this License is provided on an "AS IS" basis,
 *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
 *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
 *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
 *  See the License for the specific provisions governing your rights and
 *  obligations concerning the Software.
 *
 *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
 *
 *  Copyright: 2000 by Sun Microsystems, Inc.
 *
 *  All Rights Reserved.
 *
 *  Contributor(s): _______________________________________
 *
 *
 ************************************************************************/
#ifndef __com_sun_star_i18n_BreakIterator_idl__ 
#define __com_sun_star_i18n_BreakIterator_idl__ 
 
#ifndef __com_sun_star_linguistic2_XHyphenator_idl__ 
#include <com/sun/star/linguistic2/XHyphenator.idl> 
#endif 
#ifndef __com_sun_star_linguistic2_XHyphenatedWord_idl__ 
#include <com/sun/star/linguistic2/XHyphenatedWord.idl> 
#endif 
 
#ifndef __com_sun_star_lang_Locale_idl__ 
#include <com/sun/star/lang/Locale.idl> 
#endif 
 
 
//============================================================================= 
 
 module com {  module sun {  module star {  module i18n { 
 
//============================================================================= 
 
// DocMerge: empty anyway
constants CharacterIteratorMode
{ 
    // Iteration mode can be either character or cell based 
    
    // DocMerge: empty anyway
    const short SKIPCHARACTER 			= 0; 
    
    // DocMerge: empty anyway
    const short SKIPCELL 				= 1; 
    
    // DocMerge: empty anyway
    const short SKIPCONTROLCHARACTER 	= 2; 
}; 
 
// DocMerge: empty anyway
constants BreakType
{ 
    // DocMerge: empty anyway
    const short WORDBOUNDARY			= 1; 
    
    // DocMerge: empty anyway
    const short HYPHENATION				= 2; 
    
    // DocMerge: empty anyway
    const short HANGINGPUNCTUATION		= 3; 
}; 
 
// DocMerge: empty anyway
constants ScriptType
{ 
    // DocMerge: empty anyway
    const short LATIN					= 1; 
    
    // DocMerge: empty anyway
    const short ASIAN					= 2; 
    
    // DocMerge: empty anyway
    const short COMPLEX					= 3; 
    
    // DocMerge: empty anyway
    const short WEAK					= 4; 
}; 
 
// DocMerge: empty anyway
constants WordType
{ 
    // DocMerge: empty anyway
    const short ANY_WORD                 = 0; 
    
    // DocMerge: empty anyway
    const short ANYWORD_IGNOREWHITESPACES= 1; 
    
    // DocMerge: empty anyway
    const short DICTIONARY_WORD          = 2; 
}; 
 
// DocMerge: empty anyway
constants CharType
{ 
    // DocMerge: empty anyway
    const short ANY_CHAR                 = 0; 
    
    // DocMerge: empty anyway
    const short LOWER_CASE_CHAR          = 1; 
}; 
 
// DocMerge: empty anyway
struct LineBreakUserOptions
{
    // DocMerge: empty anyway
    string forbiddenBeginCharacters; 
    
    // DocMerge: empty anyway
    string forbiddenEndCharacters; 
    
    // DocMerge: empty anyway
    boolean applyForbiddenRules; 
    
    // DocMerge: empty anyway
    boolean allowPunctuationOutsideMargin; 
    
    // DocMerge: empty anyway
    boolean allowHyphenateEnglish; 
 
}; 
 
// DocMerge: empty anyway
struct LineBreakHyphenationOptions
{
    // DocMerge: empty anyway
    ::com::sun::star::linguistic2::XHyphenator rHyphenator; 
     
    // DocMerge: empty anyway
    long  hyphenIndex; 
}; 
 
// DocMerge: empty anyway
struct LineBreakResults
{
    // DocMerge: empty anyway
    short breakType; 
    
    // DocMerge: empty anyway
    long  breakIndex; 
    
    // DocMerge: empty anyway
    ::com::sun::star::linguistic2::XHyphenatedWord rHyphenatedWord; 
}; 
 
// DocMerge: empty anyway
struct Boundary
{
    // DocMerge: empty anyway
    long startPos ; // Inclusive 
    
    // DocMerge: empty anyway
    long endPos   ; // exclusive 
}; 
 
 
// DocMerge: empty anyway
[ uik(779C6834-2510-40b7-8480B56E-D912E71C), ident( "XBreakIterator", 1.0 ) ]
interface XBreakIterator: com::sun::star::uno::XInterface
{ 
 
 
// Assumption - StartPos is inclusive and EndPos is exclusive. 
 
    // Traverses nCount characters in Text from nStartPos. Iteration mode can be cell based or 
    // character based.A cell is made of more than one character. 
    
    // DocMerge: empty anyway
    [const] long 	nextCharacters( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale rLocale, 
                                    [in] short nCharacterIteratorMode, [in] long nCount, [out] long nDone ); 
    
    // DocMerge: empty anyway
    [const] long 	previousCharacters( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale, 
                                        [in] short nCharacterIteratorMode, [in] long nCount, [out] long nDone ); 
 
    /* 
        traverses nCount words forward and returns word boundary both start and end position of the word. To process 
        control +right Use pos  = nextWords (text, pos, locale, ANYWORD_IGNOREWHITESPACES, 1, &nDone);pos.startPos should have 
        cursor position. 
    */ 
    // DocMerge: empty anyway
    [const] Boundary 	nextWord( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale, [in] short WordType); 
    
    // DocMerge: empty anyway
    [const] Boundary 	previousWord( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale, [in] short WordType); 
 
    /* identifies StartPos and EndPos of current word. If nPos is the boundary of a word, it is 
    startPos of one word and endPos of previous word.In this situation, the outcome of the algorithm can be indeterminate. 
    In this sitution, bPreferForward flag  is used,if bPreferForward == 0, nPos is considered end of word and looks for beginning of word on left 
    otherwise nPos is considered beginning of next word and looks right for end of the word. 
    */ 
    // DocMerge: empty anyway
    [const] Boundary getWordBoundary( [in] string Text, [in] long nPos, [in] ::com::sun::star::lang::Locale nLocale, [in] short WordType, [in] boolean bPreferForward); 
    
    // DocMerge: empty anyway
    [const] short   getWordType  ([in] string Text, [in] long nPos, [in] ::com::sun::star::lang::Locale nLocale); 
    
    // DocMerge: empty anyway
    [const] boolean isBeginWord  ([in] string Text, [in] long nPos, [in] ::com::sun::star::lang::Locale nLocale, [in] short WordType); 
    
    // DocMerge: empty anyway
    [const] boolean isEndWord    ([in] string Text, [in] long nPos, [in] ::com::sun::star::lang::Locale nLocale, [in] short WordType); 
    
    // DocMerge: empty anyway
    [const] long 	beginOfSentence( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale ); 
    
    // DocMerge: empty anyway
    [const] long 	endOfSentence( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale ); 
 
 
    // DocMerge: empty anyway
    [const] LineBreakResults getLineBreak( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale, [in] long nMinBreakPos, 
                                  [in] LineBreakHyphenationOptions hOptions, [in]LineBreakUserOptions bOptions ); 
 
 
    // DocMerge: empty anyway
    [const] long 	beginOfScript( [in] string Text, [in] long nStartPos, [in] short ScriptType ); 
    
    // DocMerge: empty anyway
    [const] long 	endOfScript( [in] string Text, [in] long nStartPos, [in] short ScriptType ); 
 
    // DocMerge: empty anyway
    [const] long 	nextScript( [in] string Text, [in] long nStartPos, [in] short ScriptType ); 
    
    // DocMerge: empty anyway
    [const] long 	previousScript ( [in] string Text, [in] long nStartPos, [in] short ScriptType ); 
    
    // DocMerge: empty anyway
    [const] short   getScriptType  ([in] string Text, [in] long nPos); 
 
 
    // DocMerge: empty anyway
    [const] long 	beginOfCharBlock( [in] string Text, [in] long nStartPos,[in] ::com::sun::star::lang::Locale nLocale, [in] short CharType ); 
    
    // DocMerge: empty anyway
    [const] long 	endOfCharBlock( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale, [in] short CharType ); 
 
    // DocMerge: empty anyway
    [const] long 	nextCharBlock( [in] string Text, [in] long nStartPos,[in] ::com::sun::star::lang::Locale nLocale, [in] short CharType ); 
    
    // DocMerge: empty anyway
    [const] long 	previousCharBlock ( [in] string Text, [in] long nStartPos, [in] ::com::sun::star::lang::Locale nLocale, [in] short CharType ); 
}; 
 
 
//============================================================================= 
 
}; }; }; }; 
 
/*============================================================================= 
 
    $Log: not supported by cvs2svn $
    Revision 1.2  2000/10/25 13:26:03  tl
    linguistic => linguistic2
    
    Revision 1.1.1.1  2000/09/18 23:36:04  hjs
    initial import
    
    Revision 1.11  2000/09/11 11:53:02  mi
    documentation merged from XML
     
    Revision 1.9  2000/07/24 13:27:18  st 
    copy right removed 
     
    Revision 1.8  2000/07/04 07:41:18  ama 
    Chg: XHyphenator instead XHyphenator1 
     
    Revision 1.7  2000/07/03 14:04:04  ama 
    More information about hyphenation 
 
    Revision 1.6  2000/06/23 11:40:28  gmu 
    changed previouswords to previousword, nextWords to nextWord 
 
    Revision 1.5  2000/06/14 13:22:59  sse 
    Merged Begin & End word routines 
 
    Revision 1.4  2000/06/14 08:24:19  sse 
    Moved the constants in package context 
 
    Revision 1.3  2000/06/13 08:12:03  sse 
    New breakiterator APIs 
 
    Revision 1.2  2000/06/09 12:58:59  mt 
    XInterface! 
 
    Revision 1.1  2000/06/07 10:56:23  mt 
    XBreakIterator 
 
    Revision 1.1.1.1  1999/11/11 09:48:40  jsc 
    new 
 
 
=============================================================================*/ 
#endif 
